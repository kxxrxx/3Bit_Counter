/* 

The system implements a 3-bit rotary counter on the Tiva Launchpad. 
The system has two input switches, SW1 (PF4) and SW2 (PF0), and 
three output LEDs --  red (PF1), blue (PF2), and green (PF3). 

- The red, blue, and green LEDs are used to display bit 0, 1, and 2 of the counter, respectively. 
- The system starts with the counter equal to 0.
- The counter increments by 1 every one second. 
  The general purpose timer TIMER0 is used to generate this periodic one second 
  delay and periodic interrupt. The counter is updated by the interrupt. 
  The priority of the periodic interrupt is 0.
-  If SW1 is pressed, the counter is incremented by 1; 
-  If SW2 is pressed, the counter is decremented by 1. 
-  Both SW1 and SW2 generate edge-triggered interrupts to update the counter. 
   The priority of the edge-triggered interrupt is 2.

000 (all off) -> 001 (red) -> 010 (blue) -> 011 (blue, red) ->
100 (green) -> 101 (green, red)  -> 110 (green, blue) -> 
111 (green, blue, red)  -> 000 (all off) and so on...

off - red - blue - pink - green - yellow - cyan - white - repeats

*/

#include <stdint.h>
#include <stdbool.h>
#include "switch_delay_interrupt_PinMux.h"
#include "inc/hw_types.h"
#include "inc/hw_memmap.h"
#include "inc/hw_gpio.h"
#include "driverlib/sysctl.h"
#include "driverlib/pin_map.h"
#include "driverlib/gpio.h"

#include "TM4C123.h"
#include "driverlib/interrupt.h"
#include "driverlib/timer.h"
#include "inc/tm4c123gh6pm.h"	//manually added by the programmer

#define 	SW1	     		GPIO_PIN_4		// PF4
#define 	SW2      		GPIO_PIN_0		// PF0
#define 	red_LED           GPIO_PIN_1		// PF1 (0x02)
#define 	blue_LED          GPIO_PIN_2		// PF2 (0x04)
#define green_LED					GPIO_PIN_3   // PF3 (0x08)

//*****************************************************************************

void PortFunctionInit(void)
{
    // Enable Peripheral Clocks 
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);

    // Enable pin PF3, PF2, and PF1 for GPIOOutput
    GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_2);
    GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_1);
    GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_3);

    // Enable pin PF0 for GPIOInput
    
    //First open the lock and select the bits we want to modify in the GPIO commit register.
    //
    HWREG(GPIO_PORTF_BASE + GPIO_O_LOCK) = GPIO_LOCK_KEY;
    HWREG(GPIO_PORTF_BASE + GPIO_O_CR) = 0x1;

    //
    //Now modify the configuration of the pins that we unlocked.
    //
    GPIOPinTypeGPIOInput(GPIO_PORTF_BASE, GPIO_PIN_0);
    GPIOPinTypeGPIOInput(GPIO_PORTF_BASE, GPIO_PIN_4);
		
//*************************************************************
//The code above is automatically generated by PinMux
//The code below should be manually added by the programmer
//*************************************************************

     //Enable pull-up on PF0
     GPIO_PORTF_PUR_R |= 0x11; 	
}

signed int  c = 0; // global variable to be used for interrupt and main

void Timer0A_Init(unsigned long period)
{
	volatile uint32_t ui32Loop;
	SYSCTL_RCGC1_R |= SYSCTL_RCGC1_TIMER0; // activate timer0
  ui32Loop = SYSCTL_RCGC1_R;				// Do a dummy read to insert a few cycles after enabling the peripheral.
  TIMER0_CTL_R &= ~0x00000001;     // disable timer0A during setup
  TIMER0_CFG_R = 0x00000000;       // configure for 32-bit timer mode
  TIMER0_TAMR_R = 0x00000002;      // configure for periodic mode, default down-count settings
  TIMER0_TAILR_R = period-1;       // reload value
	NVIC_PRI4_R &= ~0xE0000000; 	 // configure Timer0A interrupt priority as 0
  NVIC_EN0_R |= 0x00080000;     // enable interrupt 19 in NVIC (Timer0A)
	TIMER0_IMR_R |= 0x00000001;      // arm timeout interrupt
  TIMER0_CTL_R |= 0x00000001;      // enable timer0A																	// configure GPIOF interrupt priority as 0 
}

void Timer0A_Handler(void)
{
	  // acknowledge flag for Timer0A
	  TIMER0_ICR_R |= 0X00000001;
	
    // Update the periodic interrupt counter.
	  c++;
	  
		if(c > 7)
				{
						c = 0;  // go back to the beginning
				}
		if(c < 0)
				{
						c = 7; // go to the end
				}
}	

void Interrupt_Init(void)
{
	
	NVIC_EN0_R |= 0x40000000;  		// enable interrupt 30 in NVIC (GPIOF)
	NVIC_PRI7_R = (NVIC_PRI7_R&0xFF00FFFF)|0x00400000; 		// configure GPIOF interrupt priority as 2
	GPIO_PORTF_IM_R |= 0x11;   		// arm interrupt on PF0 and PF4
	GPIO_PORTF_IS_R &= ~0x11;     // PF0 and PF4 are edge-sensitive
  GPIO_PORTF_IBE_R |= 0x11;   	// PF0 and PF4 both edges trigger 
  GPIO_PORTF_IEV_R &= ~0x11;  	// PF0 and PF4 falling edge event
}

void GPIOPortF_Handler(void)
	{
		//switch debounce
		NVIC_EN0_R &= ~0x40000000; 
		SysCtlDelay(5333); // 160000*(1/3)*(1/10)
		NVIC_EN0_R |= 0x40000000; 
	
		if(GPIO_PORTF_RIS_R&0x10) // polls SW1
		{
			GPIOIntClear(GPIO_PORTF_BASE, GPIO_PIN_4); // acknowledge flag for PF4
			c++; //counter incremented by 1
		}
		
			if(GPIO_PORTF_RIS_R&0x01) // polls SW2
		{
			GPIOIntClear(GPIO_PORTF_BASE, GPIO_PIN_0); // acknowledge flag for PF0
			c--; //counter decremented by 1
		}
}

int main(void)
{
	 //reload value to Timer0A to generate one second delay
	 unsigned long period = 16000000; 
	
   //initialize the GPIO ports	
   PortFunctionInit();
	
	 //initialize Timer0 and configure the interrupt
	 Timer0A_Init(period);
	
   //configure the GPIOF interrupt
   Interrupt_Init();
	 
   // globally enable interrupt
	 IntMasterEnable();       		
	
   while(1) // Loop forever.
	  {
					switch(c)
          {
              case 0: //  000 = all off
              {   
                  GPIOPinWrite(GPIO_PORTF_BASE, green_LED, 0x00);	 // all off
                  GPIOPinWrite(GPIO_PORTF_BASE, blue_LED, 0x00);	
								  GPIOPinWrite(GPIO_PORTF_BASE, red_LED, 0x00);  
                  break;
              }
              case 1: // 001 = red
              {
                  GPIOPinWrite(GPIO_PORTF_BASE, green_LED, 0x00);	 
                  GPIOPinWrite(GPIO_PORTF_BASE, blue_LED, 0x00);	
								  GPIOPinWrite(GPIO_PORTF_BASE, red_LED, 0x02);				// red             
                  break;
              }
	            case 2: // 010 = blue
              {
                  GPIOPinWrite(GPIO_PORTF_BASE, green_LED, 0x00);	 
                  GPIOPinWrite(GPIO_PORTF_BASE, blue_LED, 0x04);	    // blue
								  GPIOPinWrite(GPIO_PORTF_BASE, red_LED, 0x00);     
                  break;
              }
 	            case 3: // 011 = blue, red              
						  {
                  GPIOPinWrite(GPIO_PORTF_BASE, green_LED, 0x00);	             
  								GPIOPinWrite(GPIO_PORTF_BASE, blue_LED, 0x04);	   // blue
                  GPIOPinWrite(GPIO_PORTF_BASE, red_LED, 0x02);       // red
                  break;
              }
					    case 4: // 100 = green              
					    {
                  GPIOPinWrite(GPIO_PORTF_BASE, green_LED, 0x08);	 // green
                  GPIOPinWrite(GPIO_PORTF_BASE, blue_LED, 0x00);	
								  GPIOPinWrite(GPIO_PORTF_BASE, red_LED, 0x00);  
                  break;
              }
					    case 5: // 101 = green, red
				  	 {
                  GPIOPinWrite(GPIO_PORTF_BASE, green_LED, 0x08);	 // green
                  GPIOPinWrite(GPIO_PORTF_BASE, blue_LED, 0x00);
                  GPIOPinWrite(GPIO_PORTF_BASE, red_LED, 0x02);       // red
                  break;
              }
						  case 6: // 110 = green, blue             
						  {
                  GPIOPinWrite(GPIO_PORTF_BASE, green_LED, 0x08);	 // green
                  GPIOPinWrite(GPIO_PORTF_BASE, blue_LED, 0x04);	   // blue
								  GPIOPinWrite(GPIO_PORTF_BASE, red_LED, 0x00);  
                  break;
              }
						case 7: // 111 = green, blue, red            
						 {
                  GPIOPinWrite(GPIO_PORTF_BASE, green_LED, 0x08);	 // green
                  GPIOPinWrite(GPIO_PORTF_BASE, blue_LED, 0x04);	   // blue
								  GPIOPinWrite(GPIO_PORTF_BASE, red_LED, 0x02);       // red
                  break;
              }
	        default: // all off
              {
                  GPIOPinWrite(GPIO_PORTF_BASE, green_LED, 0x00);	 
                  GPIOPinWrite(GPIO_PORTF_BASE, blue_LED, 0x00);	
								  GPIOPinWrite(GPIO_PORTF_BASE, red_LED, 0x00);  
                  break;
              }
    	}
}
}
