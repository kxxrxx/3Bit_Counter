//*****************************************************************************
// Copyright (c) 2014 Texas Instruments Incorporated.  All rights reserved.
// Software License Agreement
// 
//   Redistribution and use in source and binary forms, with or without
//   modification, are permitted provided that the following conditions
//   are met:
// 
//   Redistributions of source code must retain the above copyright
//   notice, this list of conditions and the following disclaimer.
// 
//   Redistributions in binary form must reproduce the above copyright
//   notice, this list of conditions and the following disclaimer in the
//   documentation and/or other materials provided with the  
//   distribution.
// 
//   Neither the name of Texas Instruments Incorporated nor the names of
//   its contributors may be used to endorse or promote products derived
//   from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// This file was automatically generated by the Tiva C Series PinMux Utility
// Version: 1.0.4
//
/* 

The system implements a 3-bit rotary counter on the Tiva Launchpad. 
The system has two input switches, SW1 (PF4) and SW2 (PF0), and 
three output LEDs --  red (PF1), blue (PF2), and green (PF3). 

- The red, blue, and green LEDs are used to display bit 0, 1, and 2 of the counter, respectively. 
- The system starts with the counter equal to 0.
- The counter increments by 1 every one second. 
  The general purpose timer TIMER0 is used to generate this periodic one second 
  delay and periodic interrupt. The counter is updated by the interrupt. 
  The priority of the periodic interrupt is 0.
-  If SW1 is pressed, the counter is incremented by 1; 
-  If SW2 is pressed, the counter is decremented by 1. 
-  Both SW1 and SW2 generate edge-triggered interrupts to update the counter. 
   The priority of the edge-triggered interrupt is 2.

000 (all off) -> 001 (red) -> 010 (blue) -> 011 (blue, red) ->
100 (green) -> 101 (green, red)  -> 110 (green, blue) -> 
111 (green, blue, red)  -> 000 (all off) and so on...

*/

#include <stdint.h>
#include <stdbool.h>
#include "switch_delay_interrupt_PinMux.h"
#include "inc/hw_types.h"
#include "inc/hw_memmap.h"
#include "inc/hw_gpio.h"
#include "driverlib/sysctl.h"
#include "driverlib/pin_map.h"
#include "driverlib/gpio.h"
#include "driverlib/interrupt.h"

#include "driverlib/timer.h"
#include "inc/tm4c123gh6pm.h"	//manually added by the programmer

#define 	SW1	     		GPIO_PIN_4		// PF4
#define 	SW2      		GPIO_PIN_0		// PF0
#define 	red_LED           	GPIO_PIN_1		// PF1 (0x02)
#define 	blue_LED          	GPIO_PIN_2		// PF2 (0x04)
#define 	green_LED		GPIO_PIN_3   		// PF3 (0x08)

//*****************************************************************************

void PortFunctionInit(void)
{
    // Enable Peripheral Clocks 
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);

    // Enable pin PF3, PF2, and PF1 for GPIOOutput
    GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_2);
    GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_1);
    GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_3);

    // Enable pin PF0 for GPIOInput
    
    //First open the lock and select the bits we want to modify in the GPIO commit register.
    //
    HWREG(GPIO_PORTF_BASE + GPIO_O_LOCK) = GPIO_LOCK_KEY;
    HWREG(GPIO_PORTF_BASE + GPIO_O_CR) = 0x1;

    //
    //Now modify the configuration of the pins that we unlocked.
    //
    GPIOPinTypeGPIOInput(GPIO_PORTF_BASE, GPIO_PIN_0);
    GPIOPinTypeGPIOInput(GPIO_PORTF_BASE, GPIO_PIN_4);
		
//*************************************************************
//The code above is automatically generated by PinMux
//The code below should be manually added by the programmer
//*************************************************************
		
  //Enable pull-up on PF0
  GPIO_PORTF_PUR_R |= 0x11; 	
}

void
Interrupt_Init(void)
{
  IntEnable(INT_GPIOF);  		// enable interrupt 30 in NVIC (GPIOF)
  IntPrioritySet(INT_GPIOF, 0x02); 	// configure GPIOF interrupt priority as 2
  GPIO_PORTF_IM_R |= 0x11;   		// arm interrupt on PF0 and PF4
  GPIO_PORTF_IS_R &= ~0x11;     	// PF0 and PF4 are edge-sensitive
  GPIO_PORTF_IBE_R &= ~0x11;   		// PF0 and PF4 not both edges trigger 
  GPIO_PORTF_IEV_R &= ~0x11;  		// PF0 and PF4 falling edge event
  IntMasterEnable();       		// globally enable interrupt
}

void
Timer0IntHandler(void)
{
    char cOne, cTwo;

    //
    // Clear the timer interrupt.
    //
    ROM_TimerIntClear(TIMER0_BASE, TIMER_TIMA_TIMEOUT);

    //
    // Toggle the flag for the first timer.
    //
    HWREGBITW(&g_ui32Flags, 0) ^= 1;

    //
    // Use the flags to Toggle the LED for this timer
    //
    GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1, g_ui32Flags << 1);

    //
    // Update the interrupt status on the display.
    //
    ROM_IntMasterDisable();
    cOne = HWREGBITW(&g_ui32Flags, 0) ? '1' : '0';
    cTwo = HWREGBITW(&g_ui32Flags, 1) ? '1' : '0';
    UARTprintf("\rT1: %c  T2: %c", cOne, cTwo);
    ROM_IntMasterEnable();
}

signed char  c = 0; // global variable to be used for interrupt and main

void GPIOPortF_Handler(void){
	if(GPIO_PORTF_RIS_R&0x10) // polls SW1
	{
		GPIOIntClear(GPIO_PORTF_BASE, GPIO_PIN_4); // acknowledge flag for PF4
		c++; //counter incremented by 1
	}
	
  	if(GPIO_PORTF_RIS_R&0x01) // polls SW2
	{
		GPIOIntClear(GPIO_PORTF_BASE, GPIO_PIN_0); // acknowledge flag for PF0
		c--; //counter decremented by 1
	}
	if(c > 7)
	{
        	c = 0;  // go back to the beginning
      }
      if(c < 0)
        {
        	c = 7; // go to the end
        }
}


int main(void)
{
   //initialize the GPIO ports	
   PortFunctionInit();
	
   //configure the GPIOF interrupt
   Interrupt_Init();
	
   while(1) // Loop forever.
	  {
          switch(c)
          {
              case 0: //  000 = all off
              {   
                  GPIOPinWrite(GPIO_PORTF_BASE, green_LED, 0x00);	 // all off
                  GPIOPinWrite(GPIO_PORTF_BASE, blue_LED, 0x00);	
								  GPIOPinWrite(GPIO_PORTF_BASE, red_LED, 0x00);  
                  break;
              }
              case 1: // 001 = red
              {
                  GPIOPinWrite(GPIO_PORTF_BASE, green_LED, 0x00);	 
                  GPIOPinWrite(GPIO_PORTF_BASE, blue_LED, 0x00);	
								  GPIOPinWrite(GPIO_PORTF_BASE, red_LED, 0x02);				// red             
                  break;
              }
	            case 2: // 010 = blue
              {
                  GPIOPinWrite(GPIO_PORTF_BASE, green_LED, 0x00);	 
                  GPIOPinWrite(GPIO_PORTF_BASE, blue_LED, 0x04);	    // blue
								  GPIOPinWrite(GPIO_PORTF_BASE, red_LED, 0x00);     
                  break;
              }
 	            case 3: // 011 = blue, red              
						  {
                  GPIOPinWrite(GPIO_PORTF_BASE, green_LED, 0x00);	             
  								GPIOPinWrite(GPIO_PORTF_BASE, blue_LED, 0x04);	   // blue
                  GPIOPinWrite(GPIO_PORTF_BASE, red_LED, 0x02);       // red
                  break;
              }
					    case 4: // 100 = green              
					    {
                  GPIOPinWrite(GPIO_PORTF_BASE, green_LED, 0x08);	 // green
                  GPIOPinWrite(GPIO_PORTF_BASE, blue_LED, 0x00);	
								  GPIOPinWrite(GPIO_PORTF_BASE, red_LED, 0x00);  
                  break;
              }
					    case 5: // 101 = green, red
				  	 {
                  GPIOPinWrite(GPIO_PORTF_BASE, green_LED, 0x08);	 // green
                  GPIOPinWrite(GPIO_PORTF_BASE, blue_LED, 0x00);
                  GPIOPinWrite(GPIO_PORTF_BASE, red_LED, 0x02);       // red
                  break;
              }
						  case 6: // 110 = green, blue             
						  {
                  GPIOPinWrite(GPIO_PORTF_BASE, green_LED, 0x08);	 // green
                  GPIOPinWrite(GPIO_PORTF_BASE, blue_LED, 0x04);	   // blue
								  GPIOPinWrite(GPIO_PORTF_BASE, red_LED, 0x00);  
                  break;
              }
						case 7: // 111 = green, blue, red            
						 {
                  GPIOPinWrite(GPIO_PORTF_BASE, green_LED, 0x08);	 // green
                  GPIOPinWrite(GPIO_PORTF_BASE, blue_LED, 0x04);	   // blue
								  GPIOPinWrite(GPIO_PORTF_BASE, red_LED, 0x02);       // red
                  break;
              }
	        default: // all off
              {
                  GPIOPinWrite(GPIO_PORTF_BASE, green_LED, 0x00);	 
                  GPIOPinWrite(GPIO_PORTF_BASE, blue_LED, 0x00);	
								  GPIOPinWrite(GPIO_PORTF_BASE, red_LED, 0x00);  
                  break;
              }
    	}
}
}

